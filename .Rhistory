library(swirl)
swirl()
1:20
pi:10
15:1
?`:`
seq(1, 20)
seq(0, 10, by=0.5)
my_seq <- c(seq(5, 10, length=30))
my_seq <- seq(5, 10, length=30)
length()
length (my_seq)
1:lenght(my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq_along(my_seq)
rep(0, times = 40)
rep(c(0, 1, 2))
rep(c(0, 1, 2), times =10)
rep(c(0, 1, 2), each = 10)
1:20
pi:10
15:1
?`:`
seq(1, 20)
seq(0, 10, by=0.5)
seq(5, 10, length=30)
my_seq <- seq(5, 10, length=30)
length()
my_seq length()
length (my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq_along(my_seq)
rep(0, times = 40)
rep(c(0, 1, 2), times = 10)
rep(c(0, 1, 2), each = 10)
0.5, 55, -10, 6
num_vect (0.5, 55, -10, 6)
num_vect <- c(0.5, 55, -10, 6)
tf <- num_vect < 1
tf()
tf
num_vect >= 6
my_char <-c("My", "name", "is")
my_char
paste(my_char, collapse = " ")
my_name <- c(my_char, "Giselle_M_Toth")
my_name
paste (my_char, collapse = "my_name")
paste(my_name, collapse = " ")
paste("Hello", "world!", sep = " ")
paste(c(1:3), c("X", "Y", "Z"), sep = ""))
paste(c(1:3), c("X", "Y", "Z"), sep = "")
paste(LETTERS, 1:4, sep = "-")
x <- c(44, NA, 5, NA)
x*3
y <- rnorm(1000)
z <- rep(NA, 1000)
my_data <- sample(c(y, z), 100)
my_na <- is.na()
my_na <- is.na
my_na <-is.na(my_data)
my_na
my_data == NA
sum (my_na)
print (my_data)
my_data
0/0
Inf - Inf
library(swirl)
swirl()
x
x[1:10]
x[is.na(x)]
y <-x[!is.na(x)]
y
y[y > 0]
x[x > 0]
x[!is.na(x) & x > 0]
x <- [c(3, 5, 7)]
x [c(3, 5, 7)]
x (i.e. x[0])
x (x[0])
x [c(0)]
x[0]
x[3000]
x[c(-2, -10)]
x [-c(2, 10)]
<- c(foo = 11, bar = 2, norf = NA)
vect <- c(foo = 11, bar = 2, norf = NA)
vect
names(vect)
vect2 <- c(11, 2, NA)
names(vect2) <-c("foo", "bar", "norf")
identical(vect, vect2)
vect ["bar"]
vect[c("foo", "bar")]
my_vector <- c(1:20)
my_vector (1:20)
my_vector 1:20
my_vector [1:20]
info()
my_vector c(1:20)
my_vector <- (1:20)
my_vector <- [1:20]
my_vector (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)
my_vector <- int [1:20]
my_vector
my_vector <-1:20
my_vector
dim (my_vector)
length(my_vector)
dim(my_vector) <- c(4, 5)
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
my_matrix <- my_vector
?my_matrix
?matrix
my_matrix2 <-matrix
my_matrix2 <- my_matrix 1:20
my_matrix2 <- my_matrix(1:20, 4, 5)
my_matrix2 <- matrix(1:20, 4, 5)
identical (my_matrix2, matrix)
?identical
identical (my_matrix2, my_matrix)
patients <- ("Bill", "Gina", "Kelly", "Sean")
patients <- c("Bill", "Gina", "Kelly", "Sean")
cbind(patients <- c("Bill", "Gina", "Kelly", "Sean"), my_matrix)
cbind(patients, my_matrix)
my_data <- data.frame(patients, my_matrix)
my_data
class(data.frame)
class(my_data)
cnames <-c("patient", "age", "weight", "bp", "rating", "test")
colnames(cnames)
colnames(my_data) <- cnames
my_data
library(swirl)
swirl()
`==`
TRUE == TRUE
(FALSE == TRUE) == FALSE
6 == 7
6 < 7
10 <= 10
5 != 7
(5 == 7) == FALSE
(!5 == 7) == FALSE
!5==7
FALSE & FALSE
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE, FALSE, FALSE)
TRUE C(TRUE, FALSE, FALSE)
TRUE c(TRUE, FALSE, FALSE)
TRUE |c(TRUE, FALSE, FALSE)
TRUE || c(TRUE, FALSE, FALSE)
5 > 8 || 6 != 8 && 4 > 3.9
isTrue(6 > 4)
isTRUE(6 > 4)
identical ('twins', 'twins')
xor(5==6, !FALSE)
ints <- sample (10)
ints
ints > 5
which()
which(7)
which(c(TRUE, FALSE, TRUE))
which(c(TRUE, FALSE, TRUE))
which (ints > 7)
any()
any(ints < 0)
all()
all(ints > 0)
swirl()
library(swirl)
ls()
rm(list=ls())
swirl()
Sys.Date()
f <- function mean(c(2, 4, 5))
mean()
function mean c(2, 4, 5)
function.mean <- function c(2, 4, 5)
function.mean <- c(2, 4, 5)
mean(c(2, 4, 5))
swirl()
swirl()
mean()
x
mean.default(x)
function.mean
x=x
mean(x)
return (x= mean())
library(swirl)
swirl()
swirl()
install. packages("swirl")
packageVersion("swirl")
library(swirl)
ls()
rm(list=ls())
swirl()
2
swirl()
library(swirl)
ls()
rm(list=ls())
swirl()
d1 <- Sys.Date()
class()
class(d1)
unclass(d1)
d1
d2 <- as.date("1969-01-01")
d2 as.date("1969-01-01")
d2(as.date("1969-01-01"))
d2 <-c(as.date("1969-01-01")
d2 <-c(as.date("1969-01-01"))
d2<- (as.date("1969-01-01"))
d2
d2 <- as.Date()
d2 <- as.Date("1969-01-01")
unclass(d2)
t1 <- Sys.time()
t1
class(t1)
unclass(t1)
t2 <- as.POSIX(Sys.time())
t2 <-as.POSIXlt(Sys.time())
class(t2)
t2
unclass(t2)
str(unclass(t2))
t2$min
weekdays(d1)
months(POSIXct)
months(t1)
quarters(Q1-Q4)
quarters(t2)
t3 <- ("October 17, 1986 08:24")
t3 ("October 17, 1986 08:24")
t3 <- c("October 17, 1986 08:24")
t3 c("October 17, 1986 08:24")
t3 <- as.POSIXlt(Sys.time("October 17, 1986 08:24"))
t3
t3 "October 17, 1986 08:24"
t3 <- ["October 17, 1986 08:24"]
t3 ["October 17, 1986 08:24"]
t3 <- "October 17, 1986 08:24"
t4 <- strptime(t3, "%B %d, %Y %H:%M")
t4
class()
class(t4)
Sys.time() > t1
Sys.time() - t1)
Sys.time() - t1
difftime(Sys.time(), t1, units = 'days')
head(flags)
dim(flags)
class(flags)
cls_list <- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
sapply(lapply(flags, class))
cls_vect <-sapply(lapply(flags, class))
cls_vect (sapply(lapply(flags, class))
sapply lapply(flags, class)
cls_vect <- sapply(flags, class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[, 11:17]
head(1:6)
head(flag_colors)
lapply flag-colors, sum
lapply (flag_colors, sum)
sapply (flag_colors, sum)
sapply (flag_colors, mean)
flag_shapes <- flags[, 19:23]
lapply range()
lapply (range ())
lapply (range (flag_shapes)
lapply (range,flag_shapes)
range (lapply, flag_shapes)
lapply (flag_shapes, range)
shape_mat <- sapply (flag_shapes, range)
shape_mat
class (shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
unique_vals <-lapply(flags)
unique_vals <-lapply(unique(flags)
unique_vals <-lapply(unique()
unique_vals <-lapply(unique()
unique_vals (lapply(unique()
unique_vals <- lapply (flag_shapes, unique)
unique_vals <- lapply(flags, unique)
unique_vals
length (unique_vals)
length unique_vals
unique_vals <- sapply(flags, length)
unique_vals <- sapply(unique_vals,length)
unique_vals <- sapply length
unique_vals <- sapply (length)
unique_vals <- sapply (flags,length)
sapply (unique_vals, length)
unique_vals <- sapply(flags, unique)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
library(datasets)
data("iris")
?iris
library(datasets)
data(iris)
?iris
library(swirl)
swirl()
Sys.Date()
mean(c(2, 4, 5))
function_name <- function(arg1, arg2)
{}
function_name(value1, value2)
boring_function <- function(x) {
x
}
submit()
# You're about to write your first function! Just like you would assign a value
# to a variable with the assignment operator, you assign functions in the following
# way:
#
# function_name <- function(arg1, arg2){
#   # Maipulate arguments in some way
#   # Return a value
# }
#
# The "variable name" you assign will become the name of your function. arg1 and
# arg2 represent the arguments of your function. You can maipulate the arguments
# you specify within the function. After sourcing the function, you can use the
# function by typing:
#
# function_name(value1, value2)
#
# Below we will create a function called boring_function. This function takes
# the argument `x` as input, and returns the value of x without modifying it.
# Delete the pound sign in front of the x to make the function work! Be sure to
# save this script and type submit() in the console after you make your changes.
boring_function <- function(x) {
x
}
submit()
test_func1()
function_name <- function(arg1, arg2){
}
function_name(value1, value2)
function_name(value1, value2)
submit()
boring_function <- function(x) {
x
}
submit()
script
script()
"%p%" <- function(left, right){
paste(left, right)
}
source("path/to/file/assessment3.R")
source("path/to/file/assessment3.R")
You're about to write your first function! Just like you would assign a value
# to a variable with the assignment operator, you assign functions in the following
# way:
#
# function_name <- function(arg1, arg2){
#   # Maipulate arguments in some way
#   # Return a value
# }
#
# The "variable name" you assign will become the name of your function. arg1 and
# arg2 represent the arguments of your function. You can maipulate the arguments
# you specify within the function. After sourcing the function, you can use the
# function by typing:
#
# function_name(value1, value2)
#
# Below we will create a function called boring_function. This function takes
# the argument `x` as input, and returns the value of x without modifying it.
# Delete the pound sign in front of the x to make the function work! Be sure to
# save this script and type submit() in the console after you make your changes.
boring_function <- function(x) {
x
}
evaluate <- function(func, dat){
func(dat)
}
directory ()
getwd()
dirname coursera
dirname
getwd c:/Users/Giselle/Documents/Coursera
getwd (Users/Giselle/Documents/Coursera)
setwd c:/Users/Giselle/Documents/Coursera
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
source("ProgrammingAssignment2/cachematrix.R")
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
source ("Cachematrix.R")
setwd("c:/Users/Giselle/Documents/Coursera/ProgrammingAssignment2")
list(set = set, get = get,
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
source("ProgrammingAssignment2/cachematrix.R")
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
